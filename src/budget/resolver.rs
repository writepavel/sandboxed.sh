//! Model resolver for auto-upgrading outdated model names.
//!
//! # Problem
//! AI models often suggest outdated model versions (e.g., "claude-3.5-sonnet")
//! because their training data is stale. Newer models are typically cheaper and
//! smarter, so we want to automatically upgrade to the latest equivalent.
//!
//! # Solution
//! The `ModelResolver` maintains a mapping of:
//! - Model families (claude-sonnet, gpt-4, etc.) with their latest versions
//! - Aliases from old model IDs to new ones
//!
//! When a model is requested, the resolver:
//! 1. Checks if it's an outdated family member
//! 2. Returns the latest equivalent with upgrade info
//!
//! # Data Source
//! Families and aliases are loaded from `models_with_benchmarks.json`,
//! which is auto-generated by `scripts/merge_benchmarks.py`.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::Path;
use std::sync::Arc;
use tokio::sync::RwLock;

/// Information about a model family.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModelFamily {
    /// The latest (recommended) model in this family
    pub latest: String,
    /// All members of this family (sorted by version, latest first)
    pub members: Vec<String>,
    /// Performance tier: "flagship", "mid", or "fast"
    pub tier: String,
}

/// Result of resolving a model ID.
#[derive(Debug, Clone)]
pub struct ResolvedModel {
    /// Original model ID that was requested
    pub original: String,
    /// Resolved model ID (may be same or upgraded)
    pub resolved: String,
    /// Whether the model was upgraded
    pub upgraded: bool,
    /// Reason for upgrade (if any)
    pub reason: Option<String>,
    /// The family this model belongs to (if known)
    pub family: Option<String>,
}

impl ResolvedModel {
    /// Create a result for an unchanged model.
    pub fn unchanged(model_id: &str) -> Self {
        Self {
            original: model_id.to_string(),
            resolved: model_id.to_string(),
            upgraded: false,
            reason: None,
            family: None,
        }
    }

    /// Create a result for an upgraded model.
    pub fn upgraded(original: &str, resolved: &str, reason: &str, family: Option<&str>) -> Self {
        Self {
            original: original.to_string(),
            resolved: resolved.to_string(),
            upgraded: true,
            reason: Some(reason.to_string()),
            family: family.map(|s| s.to_string()),
        }
    }
}

/// Model resolver with family-based auto-upgrade.
#[derive(Debug, Default)]
pub struct ModelResolver {
    /// Model families: family_name -> ModelFamily
    families: HashMap<String, ModelFamily>,
    /// Direct aliases: old_model_id -> new_model_id
    aliases: HashMap<String, String>,
    /// Reverse lookup: model_id -> family_name
    model_to_family: HashMap<String, String>,
}

impl ModelResolver {
    /// Create an empty resolver.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load resolver data from the benchmark JSON file.
    pub fn load_from_file(path: impl AsRef<Path>) -> Result<Self, String> {
        let content = std::fs::read_to_string(path.as_ref())
            .map_err(|e| format!("Failed to read resolver data: {}", e))?;

        Self::load_from_json(&content)
    }

    /// Load resolver data from JSON string.
    pub fn load_from_json(json: &str) -> Result<Self, String> {
        #[derive(Deserialize)]
        struct BenchmarkFile {
            #[serde(default)]
            families: HashMap<String, ModelFamily>,
            #[serde(default)]
            aliases: HashMap<String, String>,
        }

        let data: BenchmarkFile = serde_json::from_str(json)
            .map_err(|e| format!("Failed to parse resolver data: {}", e))?;

        let mut resolver = Self {
            families: data.families.clone(),
            aliases: data.aliases,
            model_to_family: HashMap::new(),
        };

        // Build reverse lookup
        for (family_name, family) in &data.families {
            for member in &family.members {
                resolver
                    .model_to_family
                    .insert(member.clone(), family_name.clone());
            }
        }

        tracing::info!(
            "Loaded model resolver: {} families, {} aliases",
            resolver.families.len(),
            resolver.aliases.len()
        );

        Ok(resolver)
    }

    /// Resolve a potentially outdated model ID to the latest equivalent.
    ///
    /// # Examples
    /// - "claude-3.5-sonnet" → "anthropic/claude-sonnet-4.5" (upgraded)
    /// - "anthropic/claude-sonnet-4.5" → "anthropic/claude-sonnet-4.5" (unchanged)
    /// - "gpt-4o" → "openai/gpt-4.1" (upgraded)
    /// - "unknown-model" → "unknown-model" (unchanged, not in families)
    pub fn resolve(&self, model_id: &str) -> ResolvedModel {
        // 1. Check direct alias first (covers short names and old versions)
        if let Some(target) = self.aliases.get(model_id) {
            let family = self.model_to_family.get(target).map(|s| s.as_str());
            return ResolvedModel::upgraded(
                model_id,
                target,
                &format!("Alias resolved to latest"),
                family,
            );
        }

        // 2. Check if model is in a family but not the latest
        if let Some(family_name) = self.model_to_family.get(model_id) {
            if let Some(family) = self.families.get(family_name) {
                if model_id != family.latest {
                    return ResolvedModel::upgraded(
                        model_id,
                        &family.latest,
                        &format!("Upgraded to latest {} model", family_name),
                        Some(family_name),
                    );
                } else {
                    // Already the latest
                    return ResolvedModel {
                        original: model_id.to_string(),
                        resolved: model_id.to_string(),
                        upgraded: false,
                        reason: None,
                        family: Some(family_name.clone()),
                    };
                }
            }
        }

        // 3. Try fuzzy matching by normalizing the model name
        let normalized = Self::normalize(model_id);
        if let Some(target) = self.aliases.get(&normalized) {
            let family = self.model_to_family.get(target).map(|s| s.as_str());
            return ResolvedModel::upgraded(model_id, target, "Fuzzy match to latest", family);
        }

        // 4. Try to match family name directly
        for (family_name, family) in &self.families {
            if normalized.contains(family_name) || family_name.contains(&normalized) {
                return ResolvedModel::upgraded(
                    model_id,
                    &family.latest,
                    &format!("Matched to {} family", family_name),
                    Some(family_name),
                );
            }
        }

        // 5. No match - return as-is
        ResolvedModel::unchanged(model_id)
    }

    /// Check if a model ID exists and is the latest in its family.
    pub fn is_latest(&self, model_id: &str) -> bool {
        if let Some(family_name) = self.model_to_family.get(model_id) {
            if let Some(family) = self.families.get(family_name) {
                return model_id == family.latest;
            }
        }
        // Unknown models are considered "latest" (no upgrade available)
        true
    }

    /// Get the family a model belongs to.
    pub fn get_family(&self, model_id: &str) -> Option<&ModelFamily> {
        self.model_to_family
            .get(model_id)
            .and_then(|name| self.families.get(name))
    }

    /// Get all model families.
    pub fn families(&self) -> &HashMap<String, ModelFamily> {
        &self.families
    }

    /// Get all known latest model IDs (one per family).
    pub fn latest_models(&self) -> Vec<&str> {
        self.families.values().map(|f| f.latest.as_str()).collect()
    }

    /// Get all model IDs in a tier ("flagship", "mid", "fast").
    pub fn models_by_tier(&self, tier: &str) -> Vec<&str> {
        self.families
            .values()
            .filter(|f| f.tier == tier)
            .map(|f| f.latest.as_str())
            .collect()
    }

    /// Normalize a model ID for fuzzy matching.
    fn normalize(model_id: &str) -> String {
        model_id
            .to_lowercase()
            .replace([':', '-', '_', '.', '/'], "")
    }
}

/// Thread-safe model resolver wrapper.
pub type SharedModelResolver = Arc<RwLock<ModelResolver>>;

/// Create a shared model resolver, loading from default path.
pub fn load_resolver(workspace_dir: &str) -> SharedModelResolver {
    let path = format!("{}/models_with_benchmarks.json", workspace_dir);

    match ModelResolver::load_from_file(&path) {
        Ok(resolver) => {
            tracing::info!("Loaded model resolver from {}", path);
            Arc::new(RwLock::new(resolver))
        }
        Err(e) => {
            tracing::warn!("Failed to load resolver: {}. Using empty resolver.", e);
            Arc::new(RwLock::new(ModelResolver::new()))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn test_resolver() -> ModelResolver {
        let json = r#"{
            "families": {
                "claude-sonnet": {
                    "latest": "anthropic/claude-sonnet-4.5",
                    "members": ["anthropic/claude-sonnet-4.5", "anthropic/claude-3.7-sonnet", "anthropic/claude-3.5-sonnet"],
                    "tier": "mid"
                },
                "gpt-4": {
                    "latest": "openai/gpt-4.1",
                    "members": ["openai/gpt-4.1", "openai/gpt-4o"],
                    "tier": "mid"
                }
            },
            "aliases": {
                "claude-3.5-sonnet": "anthropic/claude-sonnet-4.5",
                "sonnet": "anthropic/claude-sonnet-4.5",
                "gpt-4o": "openai/gpt-4.1",
                "gpt4": "openai/gpt-4.1"
            }
        }"#;
        ModelResolver::load_from_json(json).unwrap()
    }

    #[test]
    fn test_resolve_alias() {
        let resolver = test_resolver();

        let result = resolver.resolve("claude-3.5-sonnet");
        assert!(result.upgraded);
        assert_eq!(result.resolved, "anthropic/claude-sonnet-4.5");
    }

    #[test]
    fn test_resolve_family_member() {
        let resolver = test_resolver();

        let result = resolver.resolve("anthropic/claude-3.7-sonnet");
        assert!(result.upgraded);
        assert_eq!(result.resolved, "anthropic/claude-sonnet-4.5");
    }

    #[test]
    fn test_resolve_latest_unchanged() {
        let resolver = test_resolver();

        let result = resolver.resolve("anthropic/claude-sonnet-4.5");
        assert!(!result.upgraded);
        assert_eq!(result.resolved, "anthropic/claude-sonnet-4.5");
    }

    #[test]
    fn test_resolve_unknown_unchanged() {
        let resolver = test_resolver();

        let result = resolver.resolve("some-unknown-model");
        assert!(!result.upgraded);
        assert_eq!(result.resolved, "some-unknown-model");
    }

    #[test]
    fn test_is_latest() {
        let resolver = test_resolver();

        assert!(resolver.is_latest("anthropic/claude-sonnet-4.5"));
        assert!(!resolver.is_latest("anthropic/claude-3.5-sonnet"));
        assert!(resolver.is_latest("unknown-model")); // Unknown = no upgrade
    }
}
